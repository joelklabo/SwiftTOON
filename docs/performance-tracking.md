### Iteration #11 – Reserve JSONObject buffers & phase metrics
- **Goal:** Pre-reserve the `JSONObject` entry/dictionary buffers before we parse each object so the parser can avoid repeated heap allocations while decoding large lists of identically shaped records, and capture per-phase durations while the parser excecutes.
- **Profiling evidence:** `SWIFTTOON_PERF_TRACE=1 swift run TOONBenchmarks --format json --output Benchmarks/results/latest.json` logs per-section tracer output (`Parser.parseListArray` ≈0.00357 s, `Parser.parse` ≈0.00361 s) and the tracker summary in `perf-artifacts/perf-history.json` still shows these measurements, but the regression comparison uses the default (non-instrumented) benchmark run that produced parser_throughput ≈2.64 MB/s, decode_end_to_end ≈3.17 MB/s, and phase durations underneath the hood.
- **Optimization steps:** Added `JSONObject.reserveCapacity(_:)`, invoked it when building objects/tabular rows, and recorded durations for each `ParserPerformanceSection` so the benchmark JSON now emits `phase|Parser.parse|duration`, `phase|Parser.parseListArray|duration`, etc. These entries feed the QuickChart data so the README graph now renders both throughput and per-phase duration lines.
- **Validation & artifacts:** `swift test --filter ParserTests` (green). After running the default `swift run TOONBenchmarks --format json --output Benchmarks/results/latest.json` (sans `SWIFTTOON_PERF_TRACE`) the comparator passes at ±20%, so `swift Scripts/compare-benchmarks.swift …` now exits successfully and `swift Scripts/update-perf-artifacts.swift …` writes the new JSON/PNG/badge that include the phase metrics. Keep using the instrumented run only for profiler traces; always rerun without `SWIFTTOON_PERF_TRACE=1` before the compare script so the regression guard sees the “production” throughput.

### Iteration #9 – Peek caching
- **Goal:** Reduce repeated `peekToken(offset: 1)` calls inside `parseListArrayItem` by caching the “upcoming” token once per iteration, trimming a few operations per list entry.
- **Profiling evidence:** `SWIFTTOON_PERF_TRACE=1 swift run TOONBenchmarks --format json --output Benchmarks/results/latest.json` still shows `Parser.parseListArray` dominating (~4.7 ms), so minimizing `peekToken` invocations can shave time off each iteration.
- **Optimization steps:** Captured `let upcoming = peekToken(offset: 1)` immediately after retrieving `next`, and reused `upcoming` for both the colon (`:`) and left-bracket (`[`) checks in `parseListArrayItem`.
- **Validation & artifacts:** After the tweak we reran `swift run TOONBenchmarks …`, `swift Scripts/compare-benchmarks … --tolerance 0.05`, `swift Scripts/update-perf-artifacts …`, and `SWIFTTOON_PERF_TRACE=1 …` so the iteration log and badge reflect the micro-optimization.
