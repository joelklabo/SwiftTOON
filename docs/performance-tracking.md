### Iteration #11 – Reserve JSONObject buffers
- **Goal:** Pre-reserve the `JSONObject` entry/dictionary buffers before we parse each object so the parser can avoid repeated heap allocations while decoding large lists of identically shaped records.
- **Profiling evidence:** `SWIFTTOON_PERF_TRACE=1 swift run TOONBenchmarks --format json --output Benchmarks/results/latest.json` still reports `Parser.parseListArray` ≈0.00418 s and `Parser.parse` ≈0.00421 s, so this instrumentation run (recorded as commit `891e83c…` in `perf-artifacts/perf-history.json`) provides the tracker data while `parser_micro` sits around 1.82 MB/s. Because `ParserPerformanceTracker` serializes every measurement via a `DispatchQueue`, the instrumentation run is noticeably slower than the default benchmark and should not be used for regression gating.
- **Optimization steps:** Added `JSONObject.reserveCapacity(_:)` and invoked it inside `parseObject` (plus when building tabular rows) so each object creation primes both its entry array and key dictionary before the field loop starts.
- **Validation & artifacts:** `swift test --filter ParserTests` (green). The comparison gate now uses the default benchmark run (no `SWIFTTOON_PERF_TRACE`) that produced `parser_micro`=3.193 MB/s and `decode_end_to_end`=4.009 MB/s, so `swift Scripts/compare-benchmarks.swift Benchmarks/results/latest.json Benchmarks/baseline_reference.json --tolerance 0.2` passes; the resulting `Benchmarks/perf-artifacts/*` and README badge/graph reflect those measurements. Keep using the instrumented run only when you need the tracker summary—always re-run the benchmark without `SWIFTTOON_PERF_TRACE=1` before invoking the compare script so the regression guard sees the “production” throughput.

### Iteration #9 – Peek caching
- **Goal:** Reduce repeated `peekToken(offset: 1)` calls inside `parseListArrayItem` by caching the “upcoming” token once per iteration, trimming a few operations per list entry.
- **Profiling evidence:** `SWIFTTOON_PERF_TRACE=1 swift run TOONBenchmarks --format json --output Benchmarks/results/latest.json` still shows `Parser.parseListArray` dominating (~4.7 ms), so minimizing `peekToken` invocations can shave time off each iteration.
- **Optimization steps:** Captured `let upcoming = peekToken(offset: 1)` immediately after retrieving `next`, and reused `upcoming` for both the colon (`:`) and left-bracket (`[`) checks in `parseListArrayItem`.
- **Validation & artifacts:** After the tweak we reran `swift run TOONBenchmarks …`, `swift Scripts/compare-benchmarks … --tolerance 0.05`, `swift Scripts/update-perf-artifacts …`, and `SWIFTTOON_PERF_TRACE=1 …` so the iteration log and badge reflect the micro-optimization.
