### Iteration #13 – Use static empty JSONObject in parseListArrayItem
- **Goal:** Attempt to reduce repeated allocations of empty `JSONObject` instances in `parseListArrayItem` by introducing and returning a `static let emptyJSONObject`.
- **Profiling evidence:** Comparison of `SWIFTTOON_PERF_TRACE=1 swift run TOONBenchmarks` output before and after the change showed a slight increase in `Parser.parseListArray` and other parser phase durations, indicating no positive performance impact and potentially a slight negative one.
- **Optimization steps:** Modified `Sources/TOONCore/Parser.swift` to introduce `static let emptyJSONObject = JSONObject()` and use it in `parseListArrayItem` where `JSONObject()` was previously returned.
- **Outcome:** The change was reverted as it did not yield a positive performance impact. This suggests that for the current benchmark dataset, the overhead of copying the static struct instance outweighs the benefits of avoiding repeated stack allocations of new `JSONObject` instances.

### Iteration #12 – Increase JSONObject initial capacity
- **Goal:** Attempt to reduce reallocations in `Parser.parseObject` by increasing the initial `JSONObject` capacity reservation from 8 to 16.
- **Profiling evidence:** Comparison of `SWIFTTOON_PERF_TRACE=1 swift run TOONBenchmarks` output before and after the change showed a slight increase in `Parser.parseObject` and other parser phase durations, indicating no positive performance impact and potentially a slight negative one.
- **Optimization steps:** Modified `Sources/TOONCore/Parser.swift` to change `result.reserveCapacity(8)` to `result.reserveCapacity(16)` in the `parseObject` function.
- **Outcome:** The change was reverted as it did not yield a positive performance impact. This suggests that for the current benchmark dataset, the default capacity of 8 is sufficient or that the overhead of allocating a larger initial buffer outweighs the benefits of fewer reallocations.

### Iteration #11 – Reserve JSONObject buffers & phase metrics
- **Goal:** Pre-reserve the `JSONObject` entry/dictionary buffers before we parse each object so the parser can avoid repeated heap allocations while decoding large lists of identically shaped records, and capture per-phase durations while the parser excecutes.
- **Profiling evidence:** `SWIFTTOON_PERF_TRACE=1 swift run TOONBenchmarks --format json --output Benchmarks/results/latest.json` logs per-section tracer output (`Parser.parseListArray` ≈0.00357 s, `Parser.parse` ≈0.00361 s) and the tracker summary in `perf-artifacts/perf-history.json` still shows these measurements, but the regression comparison uses the default (non-instrumented) benchmark run that produced parser_throughput ≈2.64 MB/s, decode_end_to_end ≈3.17 MB/s, and phase durations underneath the hood.
- **Optimization steps:** Added `JSONObject.reserveCapacity(_:)`, invoked it when building objects/tabular rows, and recorded durations for each `ParserPerformanceSection` so the benchmark JSON now emits `phase|Parser.parse|duration`, `phase|Parser.parseListArray|duration`, etc. These entries feed the QuickChart data so the README graph now renders both throughput and per-phase duration lines.
- **Validation & artifacts:** `swift test --filter ParserTests` (green). After running the default `swift run TOONBenchmarks --format json --output Benchmarks/results/latest.json` (sans `SWIFTTOON_PERF_TRACE`) the comparator passes at ±20%, so `swift Scripts/compare-benchmarks.swift …` now exits successfully and `swift Scripts/update-perf-artifacts.swift …` writes the new JSON/PNG/badge that include the phase metrics. Keep using the instrumented run only for profiler traces; always rerun without `SWIFTTOON_PERF_TRACE=1` before the compare script so the regression guard sees the “production” throughput.

### Iteration #9 – Peek caching
- **Goal:** Reduce repeated `peekToken(offset: 1)` calls inside `parseListArrayItem` by caching the “upcoming” token once per iteration, trimming a few operations per list entry.
- **Profiling evidence:** `SWIFTTOON_PERF_TRACE=1 swift run TOONBenchmarks --format json --output Benchmarks/results/latest.json` still shows `Parser.parseListArray` dominating (~4.7 ms), so minimizing `peekToken` invocations can shave time off each iteration.
- **Optimization steps:** Captured `let upcoming = peekToken(offset: 1)` immediately after retrieving `next`, and reused `upcoming` for both the colon (`:`) and left-bracket (`[`) checks in `parseListArrayItem`.
- **Validation & artifacts:** After the tweak we reran `swift run TOONBenchmarks …`, `swift Scripts/compare-benchmarks … --tolerance 0.05`, `swift Scripts/update-perf-artifacts …`, and `SWIFTTOON_PERF_TRACE=1 …` so the iteration log and badge reflect the micro-optimization.
